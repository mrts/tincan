#ifndef PREPAREDSTATEMENT_H__
#define PREPAREDSTATEMENT_H__

#include "../declarations.h"

// don't depend on boost when using C++11
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
  #include <memory>
#else
  #include <boost/smart_ptr/shared_ptr.hpp>
#endif

namespace tincan
{

// Will have Java ResultSet-like interface: while (r.next()) foo(r);
class RecordSet;

/** Interface for representing precompiled SQL statements.
 *
 * A SQL statement is precompiled and stored in a PreparedStatement object.
 * This object can then be used to efficiently execute this statement multiple
 * times.
 *
 * @throw DbException
 */
class PreparedStatement
{
	INTERFACE(PreparedStatement)

public:
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typedef std::shared_ptr<RecordSet>   recordset_ptr;
    typedef std::shared_ptr<PreparedStatement> ptr;
#else
    typedef boost::shared_ptr<RecordSet> recordset_ptr;
    typedef boost::shared_ptr<PreparedStatement> ptr;
#endif

    /** Bind value to the prepared statement at the given index.
     *
     * Supports int, double and std::string as of now.
     *
     * @throw DbException
     */
    template<typename T>
	void bind(int parameterIndex, const T& val);

    /** Bind null to the prepared statement.
     *
     * @throw DbException
     */
	virtual void bindNull(int parameterIndex) = 0;

    /** Reset the prepared statement object back to its initial state, ready
     * to be re-executed.
     *
     * Contrary to the intuition of many, any bound variables retain their
     * values.
     *
     * @throw DbException
     */
    virtual void reset() = 0;

    /** Clear all bound parameters.
     *
     * @throw DbException
     */
    virtual void clear() = 0;

    /** Execute the SQL query in this PreparedStatement object and return the
     * RecordSet object generated by the query.
     *
     * @return RecordSet object that contains the data produced
     * by the query; never null
     *
     * @throw DbException
     */
    virtual recordset_ptr executeQuery() = 0;

    /** Execute a SQL Data Manipulation or Definition Language statement.
     *
     * @return either (1) the row count for DML statements or (2) 0 for
     * statements that return nothing
     *
     * @throw DbException
     */
    virtual int executeUpdate() = 0;

    // FIXME: this should be a 64-bit type really
    // FIXME: information is SQLite-specific
    /** Return the row id of the most recent successful INSERT into the
     * active database. If the insert was made to a table that has a column
     * of type INTEGER PRIMARY KEY then the last value from that column is
     * used, otherwise the internal rowid value .
     *
     * @return last insert row id
     *
     * @throw DbException
     */
    virtual int getLastInsertId() = 0;

    /** Get the underlying SQL statement. */
    virtual const std::string& getSQL() const = 0;
};

class PreparedStatementFactory
{
    FACTORY(PreparedStatementFactory)

public:
    static PreparedStatement::ptr create();
};

}

#endif /* PREPAREDSTATEMENT_H */
